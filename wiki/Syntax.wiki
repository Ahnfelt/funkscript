#summary Describes the syntax of Funk.
#labels Special,Syntax

= Literals =

Comments start with a hash `#` and lasts to the end of the line. They are ignored by the compiler.

== Union ==

The union value corresponds roughly to _null_ or _nil_ in other languages. It is useful if you have no other meaningful value to return (when your functions only purpose is to perform a side effect).

{{{
()          # The union value
}}}

== Booleans ==

Truth value literals matche the regular expression `[01][?]`.

{{{
1?          # True
0?          # False
}}}

== Numbers ==

A number literal matches `[0-9]+([.][0-9]+)([eE][-+]?[0-9]+)?` and has the obvious corresponding floating point value.
{{{
20          # The number twenty
3.141592    # A bad approximation of pi
1.2e9       # 1.2 billion
}}}

== Strings ==

String literals match `["]([^"]|\\["])*["])` or `[']([^']|[']['])*['])`. Double quote strings can have escape sequences in them (a backslash followed by a code), while single quote strings interpret backslash as an ordinary character. Two single quotes after each other in a single quote string is interpreted as a literal single quote within the string. All strings are in Unicode. Additionally, identifiers that start with a uppercase letter are strings too.

{{{
"Hello, Funk"  # A text string: Hello, Funk
"\"Funky\""    # Another string: "Funky"
'It''s good'   # A third string: It's good
MyFunString    # The last string: MyFunString
}}}

== !RegExes ==

Regular expressions (actually a superset) start with `~~` and ends with `~~`. In between the last two tildes (`~`) there can be modifier codes. The syntax of regular expressions inside have not been decided yet, but I'll look at Perl when designing them. Suggestions are welcomed.

{{{
~~[a-zA-Z]+~~  # Matches any sequence of English letters.
:f {
    |~~f(o*\=s)bar~~| # Matches foooobar (any number of os) 
                      # and binds the matched os to the s
                      # variable.
}
}}}

== Lists ==

List literals start with `[` and ends with `]`. Within them are expressions separated by commas, and an optional comma at the end. Automatic semicolons are suppressed if the list parenthesis are the innermost when breaking a line.

{{{
[]             # The empty list
[1, 2, 3, 4]   # A list of four numbers: 1 2 3 4
[A, B, ]       # Demonstrating the optional trailing comma.
}}}

== Dictionaries ==

Associative container literals start with `[` and `]` like lists, but the keys are enclosed in vertical bars `| |`.

{{{
[|]              # The empty dictionary (notice the bar that distinguishes
                 # it from an empty list).
[|X| 15 |Y| 26]  # The dictionary where "X" maps to 15 and "Y" maps to 26.
}}}

== Patterns ==

A pattern matches a set of values. All the literals discussed above can be matched using the same syntax as is used to construct them. The pattern that matches anything is written `_`. If the value is needed within the expression, an variable pattern can be used, which consists of a variable identifier. It matches any value and binds that value to the corresponding value. There is a special pattern for matching variable-length lists which is a list pattern followed by the concatenation operator `&` and a pattern that matches the rest of the list.

{{{
12               # A pattern that matches the number 12
[A, B, C]        # Matches the list of the three stings "A" "B" "C"
[a, _]           # Matches any list with two elements and binds the first element to a
[_] & r          # Matches any list with at least one element, and binds a list that
                 # contains all elements but the first to `r`.
}}}

== Functions ==

Functions are enclosed in `{ }` (curly braces). A function contains any number of matching pairs of patterns and expressions, that are tried in the order they appear in the code. If an expression is empty, it's assumed that it is unit `()`. If there are no patterns, but only a single expression, the function's sole element is bound to the special variable `_` (underscore). If the curly brace is followed by `:@`, the function itself is bound to the special variable `@`. Multiple arguments are implemented with [http://en.wikipedia.org/wiki/Currying currying], but have a shorter notation that consists of putting multiple patterns next to each other within the vertical bars `| |`.

{{{
{}               # The function that discards it's sole argument and returns
                 # `()` without any side effects.
{|p1| r}         # The function that takes an argument which is required to
                 # match the `p1` pattern and returns `r`.
{:@ @}           # The function that returns itself when called.
}}}